package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

// Helper function to determine the Go type for a given value.
func getGoType(value interface{}) string {
	switch v := value.(type) {
	case bool:
		return "bool"
	case float64:
		return "float64"
	case string:
		return "string"
	case map[string]interface{}:
		return "struct"
	case []interface{}:
		if len(v) > 0 {
			elemType := reflect.TypeOf(v[0]).Kind()
			if elemType == reflect.Map {
				return "struct"
			}
			return reflect.TypeOf(v[0]).String()
		}
		return "interface{}"
	default:
		return "interface{}"
	}
}

// Recursive function to generate Go struct code from JSON.
func generateGoStruct(prefix string, jsonObj map[string]interface{}) string {
	var sb strings.Builder
	for key, value := range jsonObj {
		keyName := strings.Title(key) // Capitalize the key for export

		// Determine the Go type for the value
		goType := getGoType(value)

		switch v := value.(type) {
		case map[string]interface{}:
			// Generate a nested struct for map type
			sb.WriteString(fmt.Sprintf("%s%s %s {\n", prefix, keyName, goType))
			sb.WriteString(generateGoStruct(prefix+"  ", v))
			sb.WriteString(fmt.Sprintf("%s} `json:\"%s,omitempty\"`\n", prefix, key))
		case []interface{}:
			// Handle arrays (homogeneous arrays of basic types or structs)
			if len(v) > 0 {
				elemType := reflect.TypeOf(v[0]).Kind()
				if elemType == reflect.Map {
					// Arrays of structs
					sb.WriteString(fmt.Sprintf("%s%s []struct {\n", prefix, keyName))
					sb.WriteString(generateGoStruct(prefix+"  ", v[0].(map[string]interface{})))
					sb.WriteString(fmt.Sprintf("%s} `json:\"%s,omitempty\"`\n", prefix, key))
				} else {
					// Homogeneous arrays of basic types
					elemType := getGoType(v[0])
					sb.WriteString(fmt.Sprintf("%s%s []%s `json:\"%s,omitempty\"`\n", prefix, keyName, elemType, key))
				}
			} else {
				// Empty array, use []interface{}
				sb.WriteString(fmt.Sprintf("%s%s []interface{} `json:\"%s,omitempty\"`\n", prefix, keyName, key))
			}
		default:
			// Use appropriate Go type (default to interface{} for unknown)
			if goType == "interface{}" {
				// Handle nulls and other cases with pointers
				goType = "*" + goType
			}
			sb.WriteString(fmt.Sprintf("%s%s %s `json:\"%s,omitempty\"`\n", prefix, keyName, goType, key))
		}
	}
	return sb.String()
}

func main() {
	// Define the path to the JSON file
	jsonFile := filepath.Join("..", "config", "user_preferences.json")
	// Load and parse the JSON file
	bytes, err := os.ReadFile(jsonFile)
	if err != nil {
		fmt.Printf("Error reading JSON file: %s\n", err)
		os.Exit(1)
	}

	// Unmarshal JSON content into a map structure
	var jsonObj map[string]interface{}
	if err := json.Unmarshal(bytes, &jsonObj); err != nil {
		fmt.Printf("Error parsing JSON: %s\n", err)
		os.Exit(1)
	}

	// Generate Go struct code
	structCode := fmt.Sprintf(`
// Code generated by generateconfig; DO NOT EDIT.

package config

type UserPreferences struct {
%s}
`, generateGoStruct("    ", jsonObj))

	// Write to an output Go file
	outputFile := filepath.Join("..", "config", "auto_generated.go")

	err = os.WriteFile(outputFile, []byte(structCode), 0644)
	if err != nil {
		fmt.Printf("Error writing Go file: %s\n", err)
		os.Exit(1)
	}

	fmt.Println("Go structs generated successfully.")
}
